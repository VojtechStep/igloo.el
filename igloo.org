#+TITLE: Igloo - The Emacs Glue
#+AUTHOR: VojtechStep
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle init.el

* About
#+begin_quote
/History is scraps of evidence joined by the glue of imagination/
#+end_quote
â€‹- First image on duckduckgo for the query "famous glue quote"

This repo is my literate Emacs configuration. If you are unfamiliar with what literate programming is, basically every code snippet in this file gets yoinked out and put into the =init.el= file, which then serves as an init script for Emacs. Writing the configuration in an org file allows for (in my opinion) better documentation and organization.

To achieve the best performance, the configuration requires a build step.

Running =make= will collect all the code into =init.el= (and =early-init.el=, more on that later) and byte compile it. Once I get my hands dirty with [[https://www.emacswiki.org/emacs/GccEmacs][native compilation]], I hope to make use of it too. It will also initialize the package manager and pull all dependencies, so if you add any remote packages, it will require an internet connection.

Running =make install= will put the compiled and source files into =$PREFIX/emacs/= (PREFIX is =build= by default). If you want to OVERWRITE your existing configuration, you can use =make install PREFIX=$HOME/.config=. This does NO BACKUP. Use at your own risk.

Here's a cherry-picked list of some of the packages I use:
- [[https://github.com/emacs-evil/evil][evil-mode]] for Vim keybindings
- [[https://github.com/emacs-evil/evil-collection][evil-collection]] to get Vim keybindings where they ain't
- [[https://github.com/raxod502/straight.el][straight.el]] for package management
- [[https://github.com/jwiegley/use-package][use-package]] for package configuration
- [[https://github.com/noctuid/general.el][general.el]] for keybinding management
- [[https://github.com/bbatsov/projectile/][projectile]] for project management
- [[https://github.com/raxod502/selectrum][selectrum]] for incremental narrowing
- [[https://github.com/magit/magit][Magit]] for interfacing with Git
- [[https://github.com/skk-dev/ddskk][ddskk]] for Japanese input
- [[https://github.com/company-mode/company-mode][company-mode]] for completion
- [[https://github.com/djcb/mu][mu4e]] for mail
- [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] for smart code completion and navigation
- [[https://github.com/flycheck/flycheck][flycheck]] for error reporting
- [[https://github.com/raxod502/apheleia][apheleia]] for code formatting
- [[https://www.gnu.org/software/emacs/erc.html][ERC]] as an IRC client
- [[https://github.com/skeeto/elfeed][elfeed]] as an RSS reader

** Dependencies
- [[https://www.gnu.org/software/make/][GNU Make]]
- [[https://www.gnu.org/software/emacs/][GNU Emacs]] (only tested with versions 27+)

* Process

First thing in the file is going to be the file header. It's useful to
add a little description and enable lexical binding (it's all the rage
these days).

#+begin_src emacs-lisp
;;; Igloo --- The glue connecting my whole operating experience. YMMV -*- lexical-binding: t; -*-

;;; Commentary:
;; Read https://github.com/VojtechStep/igloo.el/blob/master/igloo.org
;;
;; DO NOT CHANGE THIS FILE
;; This file is generated from `igloo.org' and will be overwritten on
;; every invocation of `make'

;;; Code:
#+end_src

This configuration is built on the simple principle of "do what you
can at compile time". This means that we have to properly
differentiate what happens at comptime (via `eval-when-compile`), what
happens at runtime (via plain forms) and what happens during both (via
`eval-and-compile`).

To look up if we are executing in compilation or not, we set a variable to true only during compilation:

#+begin_src emacs-lisp
(eval-and-compile
  (defvar vs/--compiling nil
    "Non-nill if read when compiling."))

(eval-when-compile
  (setq vs/--compiling t))
#+end_src

First, the package manager is installed and configured at compile
time. At runtime, we only load it via its entry point, the bootstrap
file.

The =use-package= clauses need to be evaluated at both comptime, to
clone and build the packages, and at runtime to expose them to the
system.

For this reason, we define a macro to substitute the =(use-package ...)=
form with.

#+begin_src emacs-lisp
(eval-when-compile
  (defmacro vs/use-package (&rest body)
    "Passes BODY to `use-package' and call it at comptime and runtime."
    (declare (indent defun))
    `(eval-and-compile
       ,(cons 'use-package body))))
#+end_src

* Initialization

** Early init
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

Emacs 27 added =early-init.el=, which is a file that gets loaded very
early in the process (hence the name).

A word of warning: the documentation states that =early-init.el= should
be used for "customizing how the package system is initialized" and
"customizations [...] that need to be set up before initializing",
because "the early init file is read too early into the startup
process".

From [[https://git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.27#n206][etc/NEWS.27]]:

#+begin_example
,** Emacs can now be configured using an early init file.
The file is called "early-init.el", in 'user-emacs-directory'.  It is
loaded very early in the startup process: before graphical elements
such as the tool bar are initialized, and before the package manager
is initialized.  The primary purpose is to allow customizing how the
package system is initialized given that initialization now happens
before loading the regular init file (see below).

We recommend against putting any customizations in this file that
don't need to be set up before initializing installed add-on packages,
because the early init file is read too early into the startup
process, and some important parts of the Emacs session, such as
'window-system' and other GUI features, are not yet set up, which could
make some customization fail to work.

#+end_example

I try not to abuse the early init system, but I do some UI stuff that makes sense to me.

As a good citizen, we start this file with a header.

#+begin_src emacs-lisp
;;; Igloo --- Early init file -*- lexical-binding: t; -*-

;;; Commentary:
;; Read https://github.com/VojtechStep/igloo.el/blob/master/igloo.org
;;
;; DO NOT CHANGE THIS FILE
;; This file is generated from `igloo.org' and will be overwritten on
;; every invocation of `make'

;;; Code:
(eval-when-compile (require 'cl-lib))
#+end_src

*** Startup Optimizations

Many of the startup optimizations were inspired by [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][how Doom does it]]. I recommend reading it, since not all the tricks are used here, only the ones that noticeably improved the loading times for me.

In order to reduce the startup time of Emacs, we can employ several techniques. The most important part is deferred package loading, to which we will get in [[*Package management][Package management]].

**** GC Optimization

Other than that, we can start by looking into the garbage collector. The garbage collector runs when there is garbage to be picked up, that is when objects on the heap are being abandoned. We can influence when the garbage collection runs. If we wanted to have a lower memory footprint, we would want GC to run more frequently. However, in this case, we can live with a little memory spike if it provides us with a snappier experience.

Emacs garbage collector can run once the amount of allocated memory since the last GC run reaches a certain threshold, which is 8MB by default. This number is ridiculously small for most, so we increase it to about 100 megs.

Starting up is where a lot of garbage can be created, so it's easiest to pretty much disable garbage collection as soon as possible in the initialization, and re-enable it after Emacs starts. Another small-object sensitive workflows are minibuffer operations and company completion, so disable GC during those two too.

Furthermore, when enabling garbage collection, do so in a deferred manner, that is run it only after a second passes since the task (minibuffer action, completion) ends. This way, the thing running just after will still be free of garbage collection.

#+begin_src emacs-lisp
(defconst vs/--gc-threshold (* 100 1024 1024))
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6
      read-process-output-max (* 1024 1024))

(defun vs/--startup-cleanup ()
  "Reset settings disabled for faster startup."
  (setq gc-cons-threshold vs/--gc-threshold
        gc-cons-percentage 0.1))
(add-hook 'emacs-startup-hook #'vs/--startup-cleanup)


(defun vs/--gc-disable (&rest _)
  "Disable garbage collection."
  (setq gc-cons-threshold most-positive-fixnum))
(add-hook 'minibuffer-setup-hook #'vs/--gc-disable)
(add-hook 'company-completion-started-hook #'vs/--gc-disable)

(defun vs/--gc-enable ()
  "Enable garbage collection."
  (setq gc-cons-threshold vs/--gc-threshold))
(defun vs/--defer-gc-enable (&rest _)
  "Enable garbage collection, defered."
  (run-at-time 1 nil #'vs/--gc-enable))
(add-hook 'minibuffer-exit-hook #'vs/--defer-gc-enable)
(add-hook 'company-completion-finished-hook #'vs/--defer-gc-enable)

#+end_src

**** Other optimizations

We can make more optimizations by telling Emacs not to do stuff we
manage ourselves.

For starters, the look and feel (things like non-blinking cursor, menu
bar, font, ...) is configured in this file, not via X resources, so
throw the loading of those resources out of the equation.

We also don't use the =vc= framework for controlling various version
control systems, so pretend it doesn't exist by never enabling it,
ever (from docs: "An empty list disables VC altogether").

Another important feature we throw out the window is Emacs builtin
package management. It would otherwise initialize itself during
startup, and that's just not groovy.

#+begin_src emacs-lisp
(advice-add #'x-apply-session-resources :override #'ignore)

(setq vc-handled-backends nil)

(setq package-enable-at-startup nil)
#+end_src

*** Early visual stuff

As mentioned, the GNU developers warn against using early init for
graphical stuff. In this section, we are using early init for
graphical stuff. Most of the settings are here to prevent their
initialization, because it would just be wasteful to initialize them
and then disable them later.

First of all, we set the default parameters of new frames. Since early
init is done so early, they also apply to the first created frame. We
hide all the scrollbars and set the default font and background color.

We set the font because it doesn't make sense to let Emacs load a font
that's going to get replaced later. Depending on the font you choose,
it might be necessary to change the default height, which is counted
in 0.1pt.

The background color is hardcoded and you should set it to the same
background color as your main theme. It's set here because we want to
avoid another color flashing the frame before the theme is loaded.

We could also set the =menu-bar-lines= and =tool-bar-lines= variables to nil to
disable the menu bar and tool bar. Instead, we disable them by
settings the variables =menu-bar-mode= and =tool-bar-mode=. The effect is
the same, because the modes work by setting the frame parameters, but
also Emacs doesn't think those mode are enabled when they aren't.

We also disable the blinking cursor, because who came up with that?

Furthermore, =frame-resize-pixelwise= makes Emacs not align the window
size to character size. This is useful, because otherwise Emacs might
not play along with tiling window managers.
=frame-inhibit-implied-resize= set to t disables implicit resizing of
the frame by for example enabling the toolbar, the scrollbar or
changing fonts. The default setting is to preserve the number of
characters shown on screen, not the window size.

#+begin_src emacs-lisp
(setq default-frame-alist
      (append
       '((vertical-scroll-bars . nil)
         (horizontal-scroll-bars . nil)
         (font . "JetBrains Mono")
         (background-color . "#1d1f21")) ;(ref:frame-bg)
       default-frame-alist))

(set-face-attribute 'default nil :height 130)
(setq menu-bar-mode nil
      tab-bar-mode nil
      tool-bar-mode nil
      no-blinking-cursor t)

(setq-default frame-resize-pixelwise t
              frame-inhibit-implied-resize t)

#+end_src

#+begin_src emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+end_src

** Package management

First, to be able to install packages, bootstrap [[https://github.com/raxod502/straight.el][straight.el]] and
[[https://github.com/jwiegley/use-package][use-package]].

Configure straight to run on the bleeding edge and use ssh by default
to clone repositories. Those need to be =defvar='s, because neither
straight or use-package have been loaded at this point.

#+begin_src emacs-lisp
(defvar straight-check-for-modifications '(find-when-checking check-on-save))
(defvar straight-repository-branch "develop")
(defvar straight-vc-git-default-protocol 'ssh)
(defvar straight-vc-git-default-clone-depth 'full)
#+end_src

Also, configure use-package to defer by default (without having to
specify =:defer t=) and capture statistics (which can be shown by
calling =use-package-report=). The verbosity is useful for
debugging.

Deferring package loading is useful to improve startup time, because
it means that the packages themselves aren't loaded and initialized on
startup, only their autoloads are (autoloads are a mechanism for a
file to export functions that trigger a loading of the file they are
defined in when called).

The =use-package-verbose= is useful when you want to diagnose a problem
with package loading - for example to see which packages take a long
time to load, or when are packages loaded and configured.

#+begin_src emacs-lisp
(defvar use-package-compute-statistics t)
(defvar use-package-always-defer t)
(defvar use-package-verbose nil)
#+end_src

The bootstrap file location has to be accessible at both comptime
and runtime.

#+begin_src emacs-lisp
(eval-and-compile
  (defconst vs/straight-bootstrap
    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory)))
#+end_src

Install the package manager if it can't be found. This only happens
at compile time. At runtime, it is assumed that the package manager is installed.

#+begin_src emacs-lisp
(eval-when-compile
  (unless (file-exists-p vs/straight-bootstrap)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp))))
#+end_src

Once the package manager is guaranteed to be present at comptime and
runtime, load it and setup =use-package=.

First, download and compile it. Once it's present on the system,
require it. The call to =straight-use-package-mode= is necessary,
because it adds keywords to =use-package-keyword=, but the variable
hasn't been defined when loading =use-package=.

#+begin_src emacs-lisp
(eval-and-compile
  (load vs/straight-bootstrap)
  (require 'straight)
  (straight-use-package 'use-package)

  (require 'use-package)
  (straight-use-package-mode t))
#+end_src

Now that the package manager is loaded, start configuring packages.

** UI/UX

As for the appearance, I'm not a huge fan of the startup screen, so
disable it.

I also consider myself a 1337 h4x0r, so don't nag me about
advanced-level commands.

I use [[https://github.com/raxod502/selectrum][selectrum]] as a completion framework (more on that later), so I
don't care much about shorter ways I can type in commands.

#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      disabled-command-function nil
      extended-command-suggest-shorter nil)
#+end_src

This adds VIM-like (read: correct) scrolling behavior: only scroll one
line at a time, keep a fixed number of visible lines around the cursor
and /never/ recenter when the cursor goes off screen (honestly, why is
that even a thing).

#+begin_src emacs-lisp
(setq-default scroll-step 1
              scroll-margin 3
              scroll-conservatively 101)
#+end_src

There is no yes/no question important enough to require up to three
key presses more then necessary, so make all yes/no prompts into y/n
prompts.

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

I do love myself some dark theme. I go with [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow night]]. Reminder: when changing a theme, we should change the initial background color of frames in [[(frame-bg)][frame parameters]].

#+begin_src emacs-lisp
(vs/use-package color-theme-sanityinc-tomorrow
  :straight t
  :demand
  :config
  (load-theme 'sanityinc-tomorrow-night t))
#+end_src

Stuff from my previous init I either didn't understand or don't think
I need any more, keeping it here for reference (not tangled):

#+begin_src emacs-lisp :tangle no
;; This was in early-init, supposed to help with startup, maybe try and bench it
;; Reference: https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#unset-file-name-handler-alist-temporarily
(defvar vs/--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

;; I keep going back and forth on this
(setq suggest-key-bindings nil)

;; Font rendering performance tips
(setq-default font-lock-support-mode 'jit-lock-mode)
(setq-default font-lock-multiline t)
#+end_src

* Email
* Org
** Exports
** Code blocks

#+begin_src emacs-lisp
(defun vs/--org-setup-src-buffer ()
  (when (fboundp 'flycheck-disable-checker)
    (flycheck-disable-checker 'emacs-lisp-checkdoc)))
(add-hook 'org-src-mode-hook #'vs/--org-setup-src-buffer)
#+end_src

* Development


#+begin_src emacs-lisp
(provide 'init)
;;; init.el ends here
#+end_src
