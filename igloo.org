#+TITLE: Igloo - The Emacs Glue
#+AUTHOR: VojtechStep
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle init.el

* About
#+begin_quote
/History is scraps of evidence joined by the glue of imagination/
#+end_quote
â€‹- First image on duckduckgo for the query "famous glue quote"

This repo is my literate Emacs configuration. If you are unfamiliar with what literate programming is, basically every code snippet in this file gets yoinked out and put into the =init.el= file, which then serves as an init script for Emacs. Writing the configuration in an org file allows for (in my opinion) better documentation and organization.

To achieve the best performance, the configuration requires a build step.

Running =make= will collect all the code into =init.el= (and =early-init.el=, more on that later) and byte compile it. Once I get my hands dirty with [[https://www.emacswiki.org/emacs/GccEmacs][native compilation]], I hope to make use of it too. It will also initialize the package manager and pull all dependencies, so if you add any remote packages, it will require an internet connection.

Running =make install= will put the compiled and source files into =$PREFIX/emacs/= (PREFIX is =build= by default). If you want to OVERWRITE your existing configuration, you can use =make install PREFIX=$HOME/.config=. This does NO BACKUP. Use at your own risk.

Here's a cherry-picked list of some of the packages I use:
- [[https://github.com/emacs-evil/evil][evil-mode]] for Vim keybindings
- [[https://github.com/emacs-evil/evil-collection][evil-collection]] to get Vim keybindings where they ain't
- [[https://github.com/raxod502/straight.el][straight.el]] for package management
- [[https://github.com/jwiegley/use-package][use-package]] for package configuration
- [[https://github.com/noctuid/general.el][general.el]] for keybinding management
- [[https://github.com/bbatsov/projectile/][projectile]] for project management
- [[https://github.com/raxod502/selectrum][selectrum]] for incremental narrowing
- [[https://github.com/magit/magit][Magit]] for interfacing with Git
- [[https://github.com/skk-dev/ddskk][ddskk]] for Japanese input
- [[https://github.com/company-mode/company-mode][company-mode]] for completion
- [[https://github.com/djcb/mu][mu4e]] for mail
- [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] for smart code completion and navigation
- [[https://github.com/flycheck/flycheck][flycheck]] for error reporting
- [[https://github.com/raxod502/apheleia][apheleia]] for code formatting
- [[https://www.gnu.org/software/emacs/erc.html][ERC]] as an IRC client
- [[https://github.com/skeeto/elfeed][elfeed]] as an RSS reader

** Dependencies

* Process

First thing in the file is going to be the file header. It's useful to
add a little description and enable lexical binding (it's all the rage
these days).

#+begin_src emacs-lisp
;;; Igloo --- The glue connecting my whole operating experience. YMMV -*- lexical-binding: t; -*-

;;; Commentary:
;; Read https://github.com/VojtechStep/igloo.el/blob/master/igloo.org
;;
;; DO NOT CHANGE THIS FILE
;; This file is generated from `igloo.org' and will be overwritten on
;; every invocation of `make'

;;; Code:
#+end_src

This configuration is built on the simple principle of "do what you
can at compile time". This means that we have to properly
differentiate what happens at comptime (via `eval-when-compile`), what
happens at runtime (via plain forms) and what happens during both (via
`eval-and-compile`).

To look up if we are executing in compilation or not, we set a variable to true only during compilation:

#+begin_src emacs-lisp
(eval-and-compile
  (defvar vs/--compiling nil
    "Non-nill if read when compiling."))

(eval-when-compile
  (setq vs/--compiling t))
#+end_src

First, the package manager is installed and configured at compile
time. At runtime, we only load it via its entry point, the bootstrap
file.

The =use-package= clauses need to be evaluated at both comptime, to
clone and build the packages, and at runtime to expose them to the
system.

For this reason, we define a macro to substitute the =(use-package ...)=
form with.

#+begin_src emacs-lisp
(eval-when-compile
  (defmacro vs/use-package (&rest body)
    "Passes BODY to `use-package' and call it at comptime and runtime."
    `(eval-and-compile
       ,(cons 'use-package body))))
#+end_src

* Initialization

** Early init
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

Emacs 27 added =early-init.el=, which is a file that gets loaded very
early in the process (hence the name).

As a good citizen, we start this file with a header.

#+begin_src emacs-lisp
;;; Igloo --- Early init file -*- lexical-binding: t; -*-

;;; Commentary:
;; Read https://github.com/VojtechStep/igloo.el/blob/master/igloo.org
;;
;; DO NOT CHANGE THIS FILE
;; This file is generated from `igloo.org' and will be overwritten on
;; every invocation of `make'

;;; Code:
(eval-when-compile (require 'cl-lib))
#+end_src

*** Startup Optimizations

Many of the startup optimizations were inspired by [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][how Doom does it]]. I recommend reading it, since not all the tricks are used here, only the ones that noticeably improved the loading times for me.

In order to reduce the startup time of Emacs, we can employ several techniques. The most important part is deferred package loading, to which we will get in [[*Package management][Package management]].

Other than that, we can start by looking into the garbage collector. The garbage collector runs when there is garbage to be picked up, that is when objects on the heap are being abandoned. We can influence when the garbage collection runs. If we wanted to have a lower memory footprint, we would want GC to run more frequently. However, in this case, we can live with a little memory spike if it provides us with a snappier experience.

Emacs garbage collector can run once the amount of allocated memory since the last GC run reaches a certain threshold, which is 8MB by default. This number is ridiculously small for most, so we increase it to about 100 megs.

Starting up is where a lot of garbage can be created, so it's easiest to pretty much disable garbage collection as soon as possible in the initialization, and re-enable it after Emacs starts. Another small-object sensitive workflows are minibuffer operations and company completion, so disable GC during those two too.

Furthermore, when enabling garbage collection, do so in a deferred manner, that is run it only after a second passes since the task (minibuffer action, completion) ends. This way, the thing running just after will still be free of garbage collection.

#+begin_src emacs-lisp
(defconst vs/--gc-threshold (* 100 1024 1024))
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6
      read-process-output-max (* 1024 1024))

(defun vs/--startup-cleanup ()
  "Reset settings disabled for faster startup."
  (setq gc-cons-threshold vs/--gc-threshold
        gc-cons-percentage 0.1))
(add-hook 'emacs-startup-hook #'vs/--startup-cleanup)


(defun vs/--gc-disable (&rest _)
  "Disable garbage collection."
  (setq gc-cons-threshold most-positive-fixnum))
(add-hook 'minibuffer-setup-hook #'vs/--gc-disable)
(add-hook 'company-completion-started-hook #'vs/--gc-disable)

(defun vs/--gc-enable ()
  "Enable garbage collection."
  (setq gc-cons-threshold vs/--gc-threshold))
(defun vs/--defer-gc-enable (&rest _)
  "Enable garbage collection, defered."
  (run-at-time 1 nil #'vs/--gc-enable))
(add-hook 'minibuffer-exit-hook #'vs/--defer-gc-enable)
(add-hook 'company-completion-finished-hook #'vs/--defer-gc-enable)

#+end_src

*** Early visual stuff

#+begin_src emacs-lisp
;; Set the look-and-feel as early in the pipeline as possible to
;; avoid doing unnecessary work

;; Frame parameters, see
;; https://www.gnu.org/software/emacs/manual/html_node/elisp/Window-Frame-Parameters.html
(setq default-frame-alist
      (append
       '(
         ;; Hide vertical scroll bars
         (vertical-scroll-bars . nil)
         ;; Excersise to the reader
         (horizontal-scroll-bars . nil)
         ;; Hide the File, Edit, Options, ... menu bar
         (menu-bar-lines . 0)
         ;; Hide the Save, Open, Search, ... icon bar
         (tool-bar-lines . 0)
         ;; Take a wild guess
         (font . "JetBrains Mono"))
       default-frame-alist))

;; Other visual candy
(set-face-attribute 'default nil :height 130)
(setq no-blinking-cursor t)

;; Use all the space allocated by the window manager
(setq-default frame-resize-pixelwise t
              frame-inhibit-implied-resize t)

#+end_src

*** Other optimizations

#+begin_src emacs-lisp
;; Disable loading resources via X (that's what this file is for)
(advice-add #'x-apply-session-resources :override #'ignore)

;; Disable VC (real men use Magit)
(setq vc-handled-backends nil
      vc-follow-symlinks t)

;; Disable package.el
(setq package-enable-at-startup nil)

;; Try loading the theme before showing the first frame to avoid flicker
(defvar vs/--loaded-theme nil)
(when (load (expand-file-name
             (concat "straight/repos/"
                     "color-theme-sanityinc-tomorrow/"
                     "color-theme-sanityinc-tomorrow.el")
             user-emacs-directory)
            t)
  (setq vs/--loaded-theme
        (load-theme 'sanityinc-tomorrow-night t)))
#+end_src

#+begin_src emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+end_src

** Package management

First, to be able to install packages, bootstrap [[https://github.com/raxod502/straight.el][straight.el]] and
[[https://github.com/jwiegley/use-package][use-package]].

Configure straight to run on the bleeding edge and use ssh by default
to clone repositories.
Those need to be =defvar='s, because neither straight or use-package have been loaded at this point.

#+begin_src emacs-lisp
(defvar straight-check-for-modifications '(find-when-checking check-on-save))
(defvar straight-repository-branch "develop")
(defvar straight-vc-git-default-protocol 'ssh)
(defvar straight-vc-git-default-clone-depth 'full)
#+end_src

Also, configure use-package to defer by default (without having to specify =:defer t=) and capture statistics. The verbosity is useful for debugging.

#+begin_src emacs-lisp
(defvar use-package-compute-statistics t)
(defvar use-package-always-defer t)
(defvar use-package-verbose nil)
#+end_src

The bootstrap file location has to be accessible at both comptime
and runtime.

#+begin_src emacs-lisp
(eval-and-compile
  (defconst vs/straight-bootstrap
    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory)))
#+end_src

Install the package manager if it can't be found. This only happens
at compile time.

#+begin_src emacs-lisp
(eval-when-compile
  (unless (file-exists-p vs/straight-bootstrap)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp))))
#+end_src

Once the package manager is guaranteed to be present at comptime and
runtime, load it and setup =use-package=.

First, download and compile it. Once it's present on the system,
require it. The call to =straight-use-package-mode= is necessary,
because it adds keywords to =use-package-keyword=, but the variable
hasn't been defined when loading =use-package=.

#+begin_src emacs-lisp
(eval-and-compile
  (load vs/straight-bootstrap)
  (require 'straight)
  (straight-use-package 'use-package)

  (require 'use-package)
  (straight-use-package-mode t))
#+end_src

Now that the package manager is loaded, start configuring packages.

** UI/UX

As for the appearance, I'm not a huge fan of the startup screen, so disable it.
I also consider myself a 1337 h4x0r, so don't nag me about advanced-level commands.
I use [[https://github.com/raxod502/selectrum][selectrum]] as a completion framework (more on that later), so I don't care much about shorter ways I can type in the command.

#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      disabled-command-function nil
      extended-command-suggest-shorter nil)
#+end_src

This adds VIM-like (read: correct) scrolling behavior: only scroll one line at a time, keep a fixed number of visible lines around the cursor and /never/ recenter when the cursor goes off screen (honestly, why is that even a thing).

#+begin_src emacs-lisp
(setq-default scroll-step 1
              scroll-margin 3
              scroll-conservatively 101)
#+end_src

There is no yes/no question important enough to require up to three key presses more then necessary, so make all yes/no prompts into y/n prompts.

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

I do love myself some dark theme. I go with [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow night]].

#+begin_src emacs-lisp
(vs/use-package color-theme-sanityinc-tomorrow
                :straight t
                :demand
                :config
                (load-theme 'sanityinc-tomorrow-night t))
#+end_src

Stuff from my previous init I either didn't understand or don't think I need any more, keeping it here for reference (not tangled):

#+begin_src emacs-lisp :tangle no
;; This was in early-init, supposed to help with startup, maybe try and bench it
;; Reference: https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#unset-file-name-handler-alist-temporarily
(defvar vs/--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

;; I keep going back and forth on this
(setq suggest-key-bindings nil)

;; Font rendering performance tips
(setq-default font-lock-support-mode 'jit-lock-mode)
(setq-default font-lock-multiline t)
#+end_src

* Email
* Org
** Exports
** Code blocks

#+begin_src emacs-lisp
(defun vs/--org-setup-src-buffer ()
  (when (fboundp 'flycheck-disable-checker)
    (flycheck-disable-checker 'emacs-lisp-checkdoc)))
(add-hook 'org-src-mode-hook #'vs/--org-setup-src-buffer)
#+end_src

* Development


#+begin_src emacs-lisp
(provide 'init)
;;; init.el ends here
#+end_src
