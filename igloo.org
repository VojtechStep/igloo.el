#+TITLE: Igloo - The Emacs Glue
#+AUTHOR: VojtechStep
#+BABEL: :cache yes
#+PROPERTY: header-args :tangle init.el :eval never :noweb tangle

* About

#+begin_quote
/History is scraps of evidence joined by the glue of imagination/
#+end_quote
​- First image on DuckDuckGo for the query "famous glue quote"

This repo is my literate Emacs configuration. If you are unfamiliar with what literate programming is, basically every code snippet in this file gets yoinked out and put into the =init.el= file, which then serves as an init script for Emacs. Writing the configuration in an org file allows for (in my opinion) better documentation and organization.

To achieve the best performance, the configuration requires a build step.

Running =make= will collect all the code into =init.el= (and =early-init.el=, more on that later) and byte compile it. Once I get my hands dirty with [[https://www.emacswiki.org/emacs/GccEmacs][native compilation]], I hope to make use of it too. It will also initialize the package manager and pull all dependencies, so if you add any remote packages, it will require an internet connection.

Running =make install= will put the compiled and source files into =$PREFIX/emacs/= (PREFIX is =build= by default). If you want to OVERWRITE your existing configuration, you can use =make install PREFIX=$HOME/.config=. This does NO BACKUP. Use at your own risk.

Here's a cherry-picked list of some of the packages I use:
- [[https://github.com/emacs-evil/evil][evil-mode]] for Vim keybindings
- [[https://github.com/emacs-evil/evil-collection][evil-collection]] to get Vim keybindings where they ain't
- [[https://github.com/raxod502/straight.el][straight.el]] for package management
- [[https://github.com/jwiegley/use-package][use-package]] for package configuration
- [[https://github.com/noctuid/general.el][general.el]] for keybinding management
- [[https://github.com/bbatsov/projectile/][projectile]] for project management
- [[https://github.com/raxod502/selectrum][selectrum]] for incremental narrowing
- [[https://github.com/magit/magit][Magit]] for interfacing with Git
- [[https://github.com/google/mozc][mozc]] for Japanese input
- [[https://github.com/company-mode/company-mode][company-mode]] for completion
- [[https://github.com/djcb/mu][mu4e]] for mail
- [[https://github.com/emacs-lsp/lsp-mode][lsp-mode]] for smart code completion and navigation
- [[https://github.com/flycheck/flycheck][flycheck]] for error reporting
- [[https://github.com/raxod502/apheleia][apheleia]] for code formatting
- [[https://www.gnu.org/software/emacs/erc.html][ERC]] as an IRC client
- [[https://github.com/skeeto/elfeed][elfeed]] as an RSS reader

** Dependencies
- [[https://www.gnu.org/software/make/][GNU Make]]
- [[https://www.gnu.org/software/emacs/][GNU Emacs]] (only tested with versions 28+)

* Process

First thing in the file is going to be the file header. It's useful to add a little description and enable lexical binding (it's all the rage these days).

#+begin_src emacs-lisp
;;; Igloo --- The glue connecting my whole operating experience. YMMV -*- lexical-binding: t; -*-

;;; Commentary:
;; Read https://github.com/VojtechStep/igloo.el/blob/master/igloo.org
;;
;; DO NOT CHANGE THIS FILE
;; This file is generated from `igloo.org' and will be overwritten on
;; every invocation of `make'

;;; Code:

(eval-when-compile (require 'cl-macs))
#+end_src

** Philosophy

This configuration is built on the simple principle of "do what you can at compile time". This means that we have to properly differentiate what happens at comptime (via =eval-when-compile=), what happens at runtime (via plain forms) and what happens during both (via =eval-and-compile=).

To look up if we are executing in compilation or not, we set a variable to true only during compilation:

#+begin_src emacs-lisp
(eval-and-compile
  (defvar igloo--compiling nil
    "Non-nill if read when compiling."))

(eval-when-compile
  (setq igloo--compiling t))
#+end_src

First, the package manager is installed and configured at compile time. At runtime, we only load it via its entry point, the bootstrap file.

The =use-package= clauses need to be evaluated at both comptime, to clone and build the packages, and at runtime to expose them to the system.

For this reason, we define a macro to substitute the =(use-package ...)= form with.

#+begin_src emacs-lisp
(eval-when-compile
  (defmacro igloo-use-package (&rest body)
    "Passes BODY to `use-package' and call it at comptime and runtime."
    (declare (indent defun))
    `(eval-and-compile
       ,(cons 'use-package body))))
#+end_src

** Display

Emacs is generally weird with its rendering pipeline, and that's a can of worms I don't want to get into here. One big observable quirk it has is that when running in server mode, it does not initialize some variables relating to faces and such.

To interact with faces and fonts, one has to wait until at least the first frame is made, which is what this macro is for. It is also intelligent enough to recognize when no server is running, and in that case it executes the body immediately.

The macro is only available during compilation.

#+begin_src emacs-lisp
(eval-when-compile
  (defmacro igloo-run-with-frontend (&rest body)
    "Run BODY when there is a frontend.

Emacs is weird when starting as a server, ok?

Some things aren't available (like face definitions),
so you want to hook into `server-after-make-frame-hook'
\(which confusingly refers to terminal clients too),
but that doesn't fire when opening Emacs without a server...

This macro checks if a server is running, and if it is,
it adds BODY to the hook,
and removes it after the first client is created.

If a server is not running, which means that the current instance was launched
as a normal Emacs process, run BODY straight away."
    (let ((funcname (cl-gentemp "igloo--run-with-frontend-")))
      (macroexp-progn
       `((defun ,funcname ()
           ,@body
           (remove-hook 'server-after-make-frame-hook #',funcname))
         (if (daemonp)
             (add-hook 'server-after-make-frame-hook #',funcname)
           (,funcname)))))))
#+end_src

* Initialization

** Early init
:PROPERTIES:
:header-args: :tangle early-init.el
:END:

Emacs 27 added =early-init.el=, which is a file that gets loaded very early in the process (hence the name).

A word of warning: the documentation states that =early-init.el= should be used for "customizing how the package system is initialized" and "customizations [...] that need to be set up before initializing", because "the early init file is read too early into the startup process".

From [[https://git.savannah.gnu.org/cgit/emacs.git/tree/etc/NEWS.27#n206][etc/NEWS.27]]:

#+begin_example
,** Emacs can now be configured using an early init file.
The file is called "early-init.el", in 'user-emacs-directory'.  It is
loaded very early in the startup process: before graphical elements
such as the tool bar are initialized, and before the package manager
is initialized.  The primary purpose is to allow customizing how the
package system is initialized given that initialization now happens
before loading the regular init file (see below).

We recommend against putting any customizations in this file that
don't need to be set up before initializing installed add-on packages,
because the early init file is read too early into the startup
process, and some important parts of the Emacs session, such as
'window-system' and other GUI features, are not yet set up, which could
make some customization fail to work.

#+end_example

I try not to abuse the early init system, but I do some UI stuff that makes sense to me.

As a good citizen, we start this file with a header.

#+begin_src emacs-lisp
;;; Igloo --- Early init file -*- lexical-binding: t; -*-

;;; Commentary:
;; Read https://github.com/VojtechStep/igloo.el/blob/master/igloo.org
;;
;; DO NOT CHANGE THIS FILE
;; This file is generated from `igloo.org' and will be overwritten on
;; every invocation of `make'

;;; Code:
(eval-when-compile (require 'cl-lib))
#+end_src

*** Startup Optimizations

Many of the startup optimizations were inspired by [[https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#how-does-doom-start-up-so-quickly][how Doom does it]]. I recommend reading it, since not all the tricks are used here, only the ones that noticeably improved the loading times for me.

In order to reduce the startup time of Emacs, we can employ several techniques. The most important part is deferred package loading, to which we will get in [[*Package management][Package management]].

**** GC Optimization

Other than that, we can start by looking into the garbage collector. The garbage collector runs when there is garbage to be picked up, that is when objects on the heap are being abandoned. We can influence when the garbage collection runs. If we wanted to have a lower memory footprint, we would want GC to run more frequently. However, in this case, we can live with a little memory spike if it provides us with a snappier experience.

Emacs garbage collector can run once the amount of allocated memory since the last GC run reaches a certain threshold, which is 8MB by default. This number is ridiculously small for most, so we increase it to about 100 megs.

Starting up is where a lot of garbage can be created, so it's easiest to pretty much disable garbage collection as soon as possible in the initialization, and re-enable it after Emacs starts. Another small-object sensitive workflows are minibuffer operations and company completion, so disable GC during those two too.

Furthermore, when enabling garbage collection, do so in a deferred manner, that is run it only after a second passes since the task (minibuffer action, completion) ends. This way, the thing running just after will still be free of garbage collection.

#+begin_src emacs-lisp
(defconst igloo--gc-threshold (* 100 1024 1024))
(setq gc-cons-threshold most-positive-fixnum
      gc-cons-percentage 0.6
      read-process-output-max (* 1024 1024))

(defun igloo--startup-cleanup ()
  "Reset settings disabled for faster startup."
  (setq gc-cons-threshold igloo--gc-threshold
        gc-cons-percentage 0.1))
(add-hook 'emacs-startup-hook #'igloo--startup-cleanup)


(defun igloo--gc-disable (&rest _)
  "Disable garbage collection."
  (setq gc-cons-threshold most-positive-fixnum))
(add-hook 'minibuffer-setup-hook #'igloo--gc-disable)
(add-hook 'company-completion-started-hook #'igloo--gc-disable)

(defun igloo--gc-enable ()
  "Enable garbage collection."
  (setq gc-cons-threshold igloo--gc-threshold))
(defun igloo--defer-gc-enable (&rest _)
  "Enable garbage collection, defered."
  (run-at-time 1 nil #'igloo--gc-enable))
(add-hook 'minibuffer-exit-hook #'igloo--defer-gc-enable)
(add-hook 'company-completion-finished-hook #'igloo--defer-gc-enable)

#+end_src

**** Other optimizations

We can make more optimizations by telling Emacs not to do stuff we manage ourselves.

For starters, the look and feel (things like non-blinking cursor, menu bar, font, ...) are configured in this file, not via X resources, so throw the loading of those resources out of the equation.

We also don't use the =vc= framework for controlling various version control systems, so pretend it doesn't exist by never enabling it, ever (from docs: "An empty list disables VC altogether").

Another important feature we throw out the window is Emacs builtin package management. It would otherwise initialize itself during startup, and that's just not groovy.

#+begin_src emacs-lisp
(advice-add #'x-apply-session-resources :override #'ignore)

(setq vc-handled-backends nil)

(setq package-enable-at-startup nil)
#+end_src

Emacs has support for bidirectional text, which I don't have a use case for, and disabling it can improve redisplay performance.

#+begin_src emacs-lisp
(setq bidi-inhibit-bpa t)
(setq-default bidi-paragraph-direction 'left-to-right)
#+end_src

Stuff from my previous early-init I either didn't understand or don't think I need any more, keeping it here for reference (not tangled):

#+begin_src emacs-lisp :tangle no
;; This was in early-init, supposed to help with startup, maybe try and bench it
;; Reference: https://github.com/hlissner/doom-emacs/blob/develop/docs/faq.org#unset-file-name-handler-alist-temporarily
(defvar igloo--file-name-handler-alist file-name-handler-alist)
(setq file-name-handler-alist nil)

;; I keep going back and forth on this
(setq suggest-key-bindings nil)

;; Font rendering performance tips
(setq-default font-lock-support-mode 'jit-lock-mode)
(setq-default font-lock-multiline t)
#+end_src

*** Early visual stuff

As mentioned, the GNU developers warn against using early init for graphical stuff. In this section, we are using early init for graphical stuff. Most of the settings are here to prevent their initialization, because it would just be wasteful to initialize them and then disable them later.

First of all, we set the default parameters of new frames. Since early init is done so early, they also apply to the first created frame. We hide all the scrollbars, menu bars and tool bars and set the default font and background color.

We also disable the blinking cursor, because who came up with that?

#+begin_src emacs-lisp
(setq default-frame-alist
      (append
       '((vertical-scroll-bars . nil)
         (horizontal-scroll-bars . nil)
         (font . "JetBrains Mono") ;(ref:default-font)
         (background-color . "#1d1f21")) ;(ref:frame-bg)
       default-frame-alist))

(set-face-attribute 'default nil :height 130)
(setq menu-bar-mode nil
      tab-bar-mode nil
      tool-bar-mode nil
      no-blinking-cursor t)
#+end_src

We set the font because it doesn't make sense to let Emacs load a font that's going to get replaced later. Depending on the font you choose, it might be necessary to change the default height, which is counted in 0.1pt.

The background color is hardcoded and you should set it to the same background color as your main theme. It's set here because we want to avoid another color flashing the frame before the theme is loaded[fn:1].

We could also set the =menu-bar-lines= and =tool-bar-lines= frame parameters to 0 to disable the menu bar and tool bar. Instead, we disable them by settings the variables =menu-bar-mode= and =tool-bar-mode=. The effect is the same, because the modes work by setting the frame parameters, but also Emacs doesn't think those mode are enabled when they aren't.

Furthermore, =frame-resize-pixelwise= makes Emacs not align the window size to character size. This is useful, because otherwise Emacs might not play along with tiling window managers. =frame-inhibit-implied-resize= set to t disables implicit resizing of the frame by for example enabling the toolbar, the scrollbar or changing fonts. The default setting is to preserve the number of characters shown on screen, not the window size.

We also tell Emacs that we don't want to compact font caches. This might cause the memory usage to grow, especially if we were using a lot of fonts (which we don't), but the GC and redisplay can be a little faster (since GC doesn't compact font caches and redisplay doesn't have to reopen them again).

#+begin_src emacs-lisp
(setq-default frame-resize-pixelwise t
              frame-inhibit-implied-resize t
              inhibit-compacting-font-caches t)
#+end_src

#+begin_src emacs-lisp
(provide 'early-init)
;;; early-init.el ends here
#+end_src

** Package management

First, to be able to install packages, bootstrap [[https://github.com/raxod502/straight.el][straight.el]] and [[https://github.com/jwiegley/use-package][use-package]].

Configure straight to run on the bleeding edge and use ssh by default to clone repositories. Those need to be =defvar='s, because neither straight or use-package have been loaded at this point.

#+begin_src emacs-lisp
(eval-and-compile
  (defvar straight-repository-branch "develop")
  (defvar straight-vc-git-default-protocol 'ssh)
  (defvar straight-vc-git-default-clone-depth 1))
#+end_src

Straight can also automatically recompile packages if one chooses to edit the locally checked-out sources. By default, it checks at startup if the source files were changed, which can hurt startup performance. Change it to only check for edits when a file is saved, and when explicitly checking with =straight-check-package= or =straight-check-all=.

#+begin_src emacs-lisp
(defvar straight-check-for-modifications '(find-when-checking check-on-save))
#+end_src

Also, configure use-package to defer by default (without having to specify =:defer t=) and capture statistics (which can be shown by calling =use-package-report=). Verbosity is useful for debugging, but generally not necessary.

Deferring package loading is useful to improve startup time, because it means that the packages themselves aren't loaded and initialized on startup, only their autoloads are (autoloads are a mechanism for a file to export functions that trigger a loading of the file they are defined in when called).

The =use-package-verbose= is useful when you want to diagnose a problem with package loading - for example to see which packages take a long time to load, or when are packages loaded and configured.

We instruct use-package to not emit error handling code when expanding macros. They are unnecessary when one knows their config works, which is the case here, and it helps with debugging macro-expanded code. +It also allows the byte-compiler to properly process the =:functions= block of use-package+ Apparently, when byte-compiling, use-package still emits some comptime-only error checking code that trips up the byte compiler, so the =:functions= clause doesn't really work as intended, and it is still necessary to add =declare-function='s to the =:preface=.

#+begin_src emacs-lisp
(eval-and-compile
  (defvar use-package-compute-statistics t)
  (defvar use-package-always-defer t)
  (defvar use-package-verbose nil)
  (defvar use-package-expand-minimally t)
  (defvar use-package-use-theme nil))
#+end_src

The bootstrap file location has to be accessible at both comptime and runtime.

#+begin_src emacs-lisp
(eval-and-compile
  (defconst igloo-straight-bootstrap
    (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory)))
#+end_src

Install the package manager if it can't be found. This only happens at compile time. At runtime, it is assumed that the package manager, and all other packages for that matter, are installed.

#+begin_src emacs-lisp
(eval-when-compile
  (unless (file-exists-p igloo-straight-bootstrap)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp))))
#+end_src

Once the package manager is guaranteed to be present at comptime and runtime, load it and setup =use-package=.

First, download and compile it. Once it's present on the system, require it. The call to =straight-use-package-mode= is necessary, because it adds keywords to =use-package-keyword=, but the variable hasn't been defined when loading =use-package=.

#+begin_src emacs-lisp
(eval-and-compile
  (load igloo-straight-bootstrap)
  (require 'straight)
  (straight-use-package 'use-package)

  (require 'use-package)
  (straight-use-package-mode t))
#+end_src

Now that the package manager is loaded, start configuring packages.

*** TODO Managing globally installed packages

I still haven't figured out how to make straight cooperate properly with local non-vcs directories. For example, mu4e and mozc require other system components, like native binaries, to be built, so they are often included in the distro's package manager. It would be nice if one didn't have to have two copies of the repo on the disk - one from the system package manager and one from straight. I use =:load-path= for those packages for now, but I loose on the nice automatic builds and such.

** UI/UX

*** Behaviour

As for the appearance, I'm not a huge fan of the startup screen, so disable it.

I also consider myself a 1337 h4x0r, so don't nag me about advanced-level commands.

I use [[https://github.com/raxod502/selectrum][selectrum]] as a completion framework (more on that later), so I don't care much about shorter ways I can type in commands.

#+begin_src emacs-lisp
(setq inhibit-startup-screen t
      disabled-command-function nil
      extended-command-suggest-shorter nil)
#+end_src

This adds VIM-like (read: correct) scrolling behavior: only scroll one line at a time, keep a fixed number of visible lines around the cursor and /never/ recenter when the cursor goes off screen (honestly, why is that even a thing).

#+begin_src emacs-lisp
(setq-default scroll-step 1
              scroll-margin 3
              scroll-conservatively 101)
#+end_src

There is no yes/no question important enough to require up to three key presses more then necessary, so make all yes/no prompts into y/n prompts.

#+begin_src emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+end_src

When an action grows the minibuffer (for example org-drill), I don't want it to stay enlarged after the action finishes, which is the default behaviour.

#+begin_src emacs-lisp
(setq-default resize-mini-windows t)
#+end_src

I mostly use the keyboard to navigate my system, and it's a little frustrating when I have a hidden mouse pointer somewhere on the screen and it causes a part of a buffer to be highlighted. Ergo, only apply the hover overlay when the mouse is moved.

#+begin_src emacs-lisp
(setq-default mouse-highlight 1)
#+end_src

Do you like polluting your working directory with files like =.#totaly-a-file.rs=? Yeah, me neither, so disable them pesky lockfiles.

#+begin_src emacs-lisp
(setq create-lockfiles nil)
#+end_src

The fish shell, which I use, is not POSIX compliant, and has a bunch of bells and whistles that I don't need when spawning inferior shell processes. Therefore, I prefer to use the standard =/bin/sh= as the default (which should be symlinked to dash).

#+begin_src emacs-lisp
(setq shell-file-name "/bin/sh") ;(ref:default-shell)
#+end_src

*** Color theme

I do love myself a dark theme. I go with [[https://github.com/purcell/color-theme-sanityinc-tomorrow][Tomorrow night]]. Reminder: when changing a theme, we should change the initial background color of frames in [[(frame-bg)][frame parameters]].

#+begin_src emacs-lisp
(igloo-use-package color-theme-sanityinc-tomorrow
  :straight t
  :demand
  :config
  (load-theme 'sanityinc-tomorrow-night t))
#+end_src

*** Startup

I like seeing a startup message that tells me how long Emacs took to start up (lo and behold the sub-0.5s startup times).

#+begin_src emacs-lisp
(add-hook 'emacs-startup-hook
  (lambda ()
    (message "Emacs ready in %ss with %d garbage collections taking up %ss"
              (float-time (time-subtract after-init-time before-init-time))
              gcs-done gc-elapsed)))
#+end_src

*** Font

/Note that not all the source blocks are exported as-is. The first three blocks are tangled into the =igloo-run-with-frontend= invocation at the bottom, using noweb syntax./

The font itself is already set during [[(default-font)][early init]].

To tell Emacs to use different fonts, one needs to specify on which characters those fonts should be used.

For emojis, I use the [[https://github.com/googlefonts/noto-emoji][Noto Color Emoji]] font. I'm not very sure about the codepoint ranges, if anyone wants to check then feel free, but this seems to work.

#+name: setup-emoji
#+begin_src emacs-lisp :tangle no
  (let ((ranges '((#x1f000 . #x1f64f)
                  (#x1f900 . #x1f9ff))))
    (dolist (emojis ranges)
      (set-fontset-font t emojis (font-spec :family "Noto Color Emoji"))))
#+end_src

For symbols, I use Symbols Nerd Font. The codepoint ranges are taken from [[https://github.com/ryanoasis/nerd-fonts/wiki/Glyph-Sets-and-Code-Points][the project wiki]].

#+name: setup-symbols
#+begin_src emacs-lisp :tangle no
(let ((ranges '(;; Seti-UI + Custom
                (#xe5fa . #xe62b)
                ;; Devicons
                (#xe700 . #xe7c5)
                ;; Font Awesome
                (#xf000 . #xf2e0)
                ;; Font Awesome Extension
                (#xe200 . #xe2a9)
                ;; Material Design Icons
                (#xf500 . #xfd46)
                ;; Weather
                (#xe300 . #xe3eb)
                ;; Octicons
                (#xf400 . #xf4a8)
                #x2665 #x26a1 #xf27c
                ;; Powerline Extra Symbols
                (#xe0b4 . #xe0c8)
                (#xe0cc . #xe0d2)
                #xe0a3 #xe0ca #xe0d4
                ;; IEC Power Sybols
                (#x23fb . #x23fe) #x2b58
                ;; Font Logos
                (#xf300 . #xf313)
                ;; Pomicons
                (#xe000 . #xe00d))))
  (dolist (syms ranges)
    (set-fontset-font t syms "Symbols Nerd Font")))
#+end_src

**** Ligatures

Emacs does not do ligatures automatically, so one has to define a bunch of regexes (regexi?) to specify which character sequences have a change of being merged together. The list of ligatures was initially taken from the JetBrains website, then a [[https://github.com/JetBrains/JetBrainsMono/wiki/List-of-supported-symbols][wiki page]] was created, but it doesn't seem up to date, so this is updated on a best-effort basis.

#+name: setup-ligatures
#+begin_src emacs-lisp :tangle no
(let ((alist '(;;  -> -- --> ->> -< -<< --- -~ -|
               (?- . ".\\(?:--\\|[->]>?\\|<<?\\|[~|]\\)")

               ;; // /* /// //= /= /== />
               ;; /** is not supported - see https://github.com/JetBrains/JetBrainsMono/issues/202
               ;; /* cannot be conditioned on patterns followed by a whitespace,
               ;; because that would require support for lookaheads in regex.
               ;; We cannot just match on /*\s, because the whitespace would be considered
               ;; as part of the match, but the font only specifies the ligature for /* with
               ;; no trailing characters
               ;;
               (?/ . ".\\(?:/[=/]?\\|==?\\|\\*\\*?\\|[>]\\)")

               ;; */ *>
               ;; Prevent grouping of **/ as *(*/) by actively looking for **/
               ;; which consumes the triple but the font does not define a substitution,
               ;; so it's rendered normally
               (?* . ".\\(?:\\*/\\|[>/]\\)")

               ;; <!-- <<- <- <-- <=> <= <| <|| <||| <|> <: <> <-< <<< <=< <<= <== <==>
               ;; <~> << <-| <=| <~~ <~ <$> <$ <+> <+ <*> <* </ </> <->
               (?< . ".\\(?:==>\\|!--\\|~~\\|-[|<-]\\||>\\||\\{1,3\\}\\|<[=<-]?\\|=[><|=]?\\|[*+$~/-]>?\\|[:>]\\)")

               ;; := ::= :?> :? :: ::: :< :>
               (?: . ".\\(?:\\?>\\|:?=\\|::?\\|[>?<]\\)")

               ;; == =:= === => =!= =/= ==> =>>
               (?= . ".\\(?:[=>]?>\\|[:=!/]?=\\)")

               ;;  != !== !!
               (?! . ".\\(?:==?\\|!\\)")

               ;; >= >> >] >: >- >-> >>> >>= >>- >=>
               (?> . ".\\(?:[=-]>\\|>[=>-]\\|[]=:>-]\\)")

               ;; && &&&
               (?& . ".&&?")

               ;; || ||| |> ||> |||> |] |} |-> |=> |- ||- |= ||=
               (?| . ".\\(?:||?>?\\||[=-]\\|[=-]>\\|[]>}=-]\\)")

               ;; ... .. .? .= .- ..<
               (?. . ".\\(?:\\.[.<]?\\|[.?=-]\\)")

               ;; ++ +++ +>
               (?+ . ".\\(?:\\+\\+?\\|>\\)")

               ;; [| [< [||]
               (?\[ . ".\\(?:|\\(?:|]\\)?\\|<\\)")

               ;; {|
               (?{ . ".|")

               ;; ?: ?. ?? ?=
               (?? . ".[:.?=]")

               ;; ## ### #### #{ #[ #( #? #_ #_( #: #! #=
               (?# . ".\\(?:#\\{1,3\\}\\|_(?\\|[{[(?:=!]\\)")

               ;; ;;
               ;; (?\; . ".;")

               ;; __ _|_
               (?_ . ".|?_")

               ;; ~~ ~~> ~> ~- ~@
               (?~ . ".\\(?:~>\\|[>@~-]\\)")

               ;; $>
               (?$ . ".>")

               ;; ^=
               (?^ . ".=")

               ;; ]#
               (?\] . ".#")
               )))
  (dolist (char-regexp alist)
    (set-char-table-range composition-function-table (car char-regexp)
                          `([,(cdr char-regexp) 0 font-shape-gstring]))))
#+end_src

**** CJK characters

CJK characters are supposed to be visually 2 characters wide in a monospace font. I mix and match different fonts for CJK and non-CJK characters, so a bit of fiddling with the font size is necessary to keep this assumption. Otherwise, be prepared to look at unaligned tags in org-mode 😱.

The reason why it's a minor mode and not a constant is that when changing font size in a buffer with =text-scale-adjust=, only the characters with the default fontspec get resized.

#+name: setup-cjk
#+begin_src emacs-lisp
(defcustom igloo-cjk-chars-size 20
  "Font size for rendering CJK characters in `igloo-scaled-cjk-chars'."
  :group 'igloo-cjk
  :type 'number)
(define-minor-mode igloo-scaled-cjk-chars
  "Minor mode for displaying CJK characters in a bigger size
than the surrounding text."
  :global t
  :lighter nil
  :group 'igloo-cjk
  (let ((fontspec (when igloo-scaled-cjk-chars
                    (font-spec :family "Noto Sans JP" :size igloo-cjk-chars-size))))
    (dolist (charset '(cjk-misc kana bopomofo han kanbun))
      (set-fontset-font t charset fontspec))))
#+end_src

**** Loading with frontend

#+begin_src emacs-lisp
(igloo-run-with-frontend
  <<setup-emoji>>
  <<setup-symbols>>
  <<setup-ligatures>>
  (igloo-scaled-cjk-chars))
#+end_src

*** Modeline

This one is pretty easy - I extracted my modeline configuration to [[https://github.com/VojtechStep/vs-modeline.el][a separate repo]], so it's enough to just download it.

#+begin_src emacs-lisp
(igloo-use-package vs-modeline
  :straight (vs-modeline :type git
                         :host github
                         :repo "VojtechStep/vs-modeline.el"
                         :local-repo "~/Code/VojtechStep/Projects/vs-modeline.el")
  :demand t
  :config
  (vs-modeline-mode))
#+end_src

** Input

*** Japanese

I'm learning Japanese, so sometimes I need to input Japanese text. I tried [[https://github.com/skk-dev/ddskk][ddskk]] for a while, but I found the input method unintuitive, and the documentation is in Japanese, so I switched to [[https://github.com/google/mozc][mozc]], which is the open source version of Google Japanese Input.

One needs to install the mozc server and Emacs helper independently of the extension. I use a customized version of [[https://aur.archlinux.org/packages/mozc-ut-common/][mozc-ut-common]], which builds the server, the Emacs helper, copies the mozc.el package to =/usr/share/emacs/site-lisp/mozc/mozc.el=, byte compiles it, and doesn't depend on Qt. The PKGBUILD can be found [[file:extras/mozc-ut-common/PKGBUILD][here]].

Since the package isn't managed with straight (see [[*Managing globally installed packages][Managing globally installed packages]]), we don't get the autoloads from the package, so let's just require it whenever the input method is about to be changed to "japanese-mozc".

#+begin_src emacs-lisp
(igloo-use-package mozc
  :load-path "/usr/share/emacs/site-lisp/mozc"
  :custom
  (mozc-candidate-style 'echo-area)
  (default-input-method "japanese-mozc")
  (mozc-leim-title "Aあ")
  :preface
  (declare-function mozc-mode "mozc")
  (declare-function find-library-name "find-func")
  (defun vs/--input-method-maybe-require-mozc (method)
    (when (string-equal method "japanese-mozc")
      (require 'mozc)))
  :init
  (advice-add 'activate-input-method :before #'vs/--input-method-maybe-require-mozc)
  :config
  (when (and (fboundp 'native-compile-async)
             (not (subr-native-elisp-p (symbol-function #'mozc-mode))))
    (require 'find-func)
    (native-compile-async (find-library-name "mozc") nil t)))
#+end_src

*** Spell checking

I use the builtin flyspell package with [[http://aspell.net/][aspell]]. There is not a lot of customization going on, since the out-of-the-box config works well enough, but I still haven't figured out how to prevent it from putting its files into =~=, even with =ispell-cmd-args=.

#+begin_src emacs-lisp
(use-package ispell)
#+end_src

** Execution environment

I struggled a little with figuring out how to keep the environment variables used in Emacs the same as in the rest of the system. I even wrote a script that was valid fish and elisp at the same time! [[https://github.com/VojtechStep/configs/blob/b416fc4b2236374c2f88f601a076736a57b2700b/envs.el][Check it out]]!

In the end I resigned, and now I spawn a shell process to extract the environment from. Turns out it's not that big of a deal, since my fish shell starts in about 8ms.

We already changed the default shell [[(default-shell)][here]], so we need to tell the package that we want the environment extracted from the user's default shell (=$SHELL=).

The list of environment variables is something you probably want to modify for yourself.

#+begin_src emacs-lisp
(igloo-use-package exec-path-from-shell
  :straight t
  :demand
  :custom
  (exec-path-from-shell-shell-name (getenv "SHELL"))
  (exec-path-from-shell-arguments nil)
  (exec-path-from-shell-variables
   '("PATH"
     "MANPATH"
     "DISPLAY"
     "CXX"
     "CC"
     "XDG_CONFIG_HOME"
     "XDG_CACHE_HOME"
     "XDG_DATA_HOME"
     "XAUTHORITY"
     "GNUPGHOME"
     "DOTFILES_HOME"
     "CARGO_HOME"
     "RUSTUP_HOME"
     "STACK_ROOT"
     "DOCKER_CONFIG"
     "TERMINFO"
     "SCREENSHOT_DIR"
     "PYTHONSTARTUP"
     "NPM_CONFIG_USERCONFIG"
     "BROWSER"
     "FZF_DEFAULT_COMMAND"
     "FZF_DEFAULT_OPTS"
     "LESSHISTFILE"
     "LESS"
     "DOTNET_CLI_TELEMETRY_OPTOUT"
     "EMAIL"
     "NIX_PATH"))
  :config
  (exec-path-from-shell-initialize))
#+end_src
* Email
* Org

** Exports

** Code blocks

#+begin_src emacs-lisp
(add-hook
 'org-src-mode-hook
 (lambda ()
   (when (fboundp 'flycheck-disable-checker)
     (flycheck-disable-checker 'emacs-lisp-checkdoc))))
#+end_src

* Development

#+begin_src emacs-lisp
(provide 'init)
;;; init.el ends here
#+end_src

* Footnotes

[fn:1] TODO: This might be solved by somehow figuring out the color at comptime
